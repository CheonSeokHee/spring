# spring
김영한 spirng core 인프런강의
intellJ 에서 처음 run 하려고 할 때
1. project에서 sdk와 자바 버전을 같게 해주고 부트에서 아무 설정 없이 create
2. settings -> search gradle에서 intellJ로 둘 다 바꿔주기

-부트
스프링을 편하게 사용할 수 있도록 지원
스프링 애플리케니션을 쉡게 생성
톰켓과 같은 웹 서버를 내장해서 별도의 was 설정 안해도됨
쉽게 빌드를 구성할 수 있도록 starter 종속성 제공
third part 라이브러리 자동 구성



-스프링
자바 언어 기반의 프레임워크
객체지향 언어
좋은 객체지향? 애플리케이션을 개발할 수 있게 해주는 프레임워크
유연하고 변경에 용이

역할과 구현을 분리
역할: 인터페이스 (중요)
구현: 비즈니스 로직?

==> 역할이 변하면 클라이언트, 서버 모두 변경 불가피
	so 인터페이스를 안전하게 구현하자!!

스프링과 객체지향 == 다형성 중요, IOC, DI등 다형성을 활용해 역할과 구현을 편리하게 다룰수 있도록함
다형성 + OCP,DIP





SOLID(좋은 객체지향)
-SRP(단일 책임 원칙)
  한 클래스는 하나의 책임만
  하나의 책임이라는 것은 모호하다(크거나 작을 수 있으며 문맥과 상황에 다름)
  중요한 기준은 변경이다(파급효과가 적을수록 좋음)

 OCP(개방-폐쇄원칙)
 SW요소는 확장에는 열려있으나 변경에는 닫혀있어야함
 다형성을 적극 활용
 문제점: 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다, 분명 다형성을 사용했지만 ocp 원칙을 지킬 수 없음
 ==>ocp가 깨지는 현상

LSP(리스코프 치환 원칙)
객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야함
앞으로 가라는 의미
 
ISP(인터페이스 분리 원칙)
특정 클라이언트를 위해 하나의 인터페이스보다 여러개 설정이 나음
분리한다면 인터페이스 끼리의 decoupling 현상 방지
 
DIP(의존관계 역전 원칙)
추상화의 의존해야한다(DIP 위반 == 구체화의 의존하고 있다는거)
구현 클래스의 의존하지 말고, 인터페이스에 의존하라는 의미


--------------------------------------------------------------------------------------
1. 메모리 회원 저장소(MemberRepository)에 객체를 저장 로컬이나 테스트시에 사용
2. DbMemberRepository를 따로 만들어 줌
3. 클라이언트 ->  회원 서비스(MemberServiceImpl) -> 메모리 회원 저장소




DIP를 지키는 방법
- DI? 관심사의 분리(다양한 책임 == 인터페이스가 구현체를 직접 선택하는 것의 의미)

  AppConfig == 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고 연결하는
                      책임을 가지는 별도의 설정 클래스를 만들자
		     애플리케이션의 실제 동작에 필요한 구현 객체를 생성 
                      생성 객체 인스턴스 참조를 생성자를 통해서 연결 ==> DI 의존성을 낮춰줌

 		     구현 객체가 변경되더라고 AppConfig만 수정하면 됨(사용 영역 코드 절대 수정 x)
 	             코드를 실행하는 영역과 구성을 책임지는 역할을 구분
		     AppConfig처럼 의존관계를 설정하는 역할을 스프링에서는 DI컨테이너
    			
   AppConfig 리팩토링 == 구성 정보에서 역할과 구현을 명확하게 분리
                                    역할이 잘 들어남, 중복제거 
   
   
  
IOC(제어의 역전)
스프링(AppConfig)에게 제어권을 넘겨주는것
클래스 내부에 객체 생성에서 의존성 객체의 메소드 생성이 아니라
스프링이 만든 객체를 주입받아 의존성 객체의 메소드를 호출하는 구조
  
DI(의존성 주입)
객체를 사용하는 주체가 객체를 생성하는 것이 아닌
스프링에서 만든 객체를 주입 받음으로써 의존성을 낮춘다.
정적인 클래스 의존 관계 == IMPORT만 보고 코드를 예상하는 것
동적인 객체(인스턴스) 의존 관계 == 애플리케이션 실행 시점에서 실제 생성된 객체 인스턴스의 참조가
 					      연결된 의존 관계
  

@Configuration, @Bean
어노테이션을 붙여줌으로써 스프링 컨테이너에 스프링 빈을 등록한다는 의미
이제 이 컨테이너에서 객체를 불러와 사용하는 구조(key, value 구조)



스프링 빈 조회
ApplicationContext == 스프링 컨테이너 == 인터페이스
기본: getBean(빈이름, 타입)
       getBean(타입)

동일한 타입: getBeansOfType() -> 해당 타입의 모든 빈 조회 가능


beanDefinition(인터페이스) == 빈 설정 메타정보

스프링 컨테이너가 이 메타정보를 기반으로 == 스프링 빈 생성

   <<inteface>>
    BeanFactory == 스프링 컨테이너의 최상의 인터페이스
     			스프링 빈을 관리하고 조회

          |
          |

     ApplicationContext == BeanFactory 기능을 모두 상속받아 제공
				 애플리케이션을 개발 시 빈 관리/조회는 물론 다른 부가기능 필요함
				  (메세지소스, 환경변수, 이벤트, 리소스 조회) 
 
 
  어노테이션 기반 자바 코드 설정 사용
  
   

-----------------------------------------------------------------------------------
웹 어플리케이션과 싱글톤
- 스프링 == 기업용 온라인 서비스 기술 지원
- 여러 고객이 동시에 요청하는 구조
- appConfig는 요청할 때 마다 매번 생성해야 하는 불편함
- tps가 100이 나오면 생성하고 소멸되므로 트래픽 낭비
- 객체가 딱 1개만 생성되고, 공유하도록 설계 하면됨 --> 싱글톤 패턴


싱글톤 패턴
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- private 생성자를 사용해서 외부에서 임의로 new 키워드를 만드는 것을 방지
- static 영역에 객체 instance를 미리 하나 생성해서 올려둠
- private로 생성하면 외부에서 new 키워드를 만들지 못하게 한다.
- 호출할 때 마다 같은 객체 인스턴스를 반환하는 구조
- 문제점: 코드가 길어짐, DIP 위반(클라이언트가 구체 클래스의 의존)
            테스트하기 어려움, 유연성이 떨어지고 private로 자식 클래스 생성하기 어려움


스프링 컨테이너 == 싱글톤 컨테이너
- 싱글톤의 문제점을 해결하고 객체 인스턴스를 싱글톤으로 관리 --> 싱글톤 레지스트리
- 스프링 빈 == 싱글톤으로 관리되는 빈
- 고객 요청 마다 만드는 것이 아니라 이미 만들어진 객체를 공유하는 구조
- 주의점: 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지하게 ㄱ
             설계하면 안된다. --> 무상태로 설계해야 함
- 공유 필드를 조심하자!!!!!



@configuration
- 스프링 빈이 싱글톤이 되도록 보장해주어야 한다.
- CGLIB라는 스프링이 만든 바이트 코드를 조작하는 라이브러리를 사용하여 AppConfig를 상속받아 만든 클래스
- 이 임의의 클래스가 싱글톤을 보장해주는 구조
- 없다면? 싱글톤이 보장되지 않을 것
- 스프링 설정파일로 사용하기 위함
- @autowired를 통해 의존관계를 자동으로 주입시켜줌
- @componentScan은 되도록 최상위패키지에 설정해주는 것이 편함



DI
- 생성자가 하나만 있다면 @autowired 생략 가능
- 컴포넌트 스캔에 의해 스프링 빈이 생성되고 생성자가 호출
- 생성자 주입: 불변, 필수 의존 관계에서 사용
  


